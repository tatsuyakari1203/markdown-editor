// KaTeX Client-side Renderer
// Renders math expressions after HTML is generated by worker

interface KaTeXOptions {
  displayMode?: boolean;
  throwOnError?: boolean;
  errorColor?: string;
  macros?: Record<string, string>;
}

class KaTeXRenderer {
  private katex: any = null;
  private isLoading = false;
  private loadPromise: Promise<void> | null = null;

  async loadKaTeX(): Promise<void> {
    if (this.katex) return;
    if (this.loadPromise) return this.loadPromise;

    this.isLoading = true;
    this.loadPromise = this.doLoadKaTeX();
    
    try {
      await this.loadPromise;
    } finally {
      this.isLoading = false;
    }
  }

  private async doLoadKaTeX(): Promise<void> {
    try {
      // Load KaTeX from CDN
      await Promise.all([
        this.loadKaTeXScript(),
        this.loadKaTeXCSS()
      ]);
      
      this.katex = (window as any).katex;
      console.log('✅ KaTeX loaded successfully from CDN');
    } catch (error) {
      console.error('❌ Failed to load KaTeX:', error);
      throw error;
    }
  }

  private async loadKaTeXScript(): Promise<void> {
    return new Promise((resolve, reject) => {
      // Check if KaTeX is already loaded
      if ((window as any).katex) {
        resolve();
        return;
      }

      // Temporarily disable AMD to avoid conflicts with Monaco Editor
      const originalDefine = (window as any).define;
      const originalRequire = (window as any).require;
      
      // Disable AMD
      if (originalDefine) {
        (window as any).define = undefined;
      }
      if (originalRequire) {
        (window as any).require = undefined;
      }

      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js';
      script.crossOrigin = 'anonymous';
      
      script.onload = () => {
        // Load auto-render extension
        const autoRenderScript = document.createElement('script');
        autoRenderScript.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js';
        autoRenderScript.crossOrigin = 'anonymous';
        autoRenderScript.onload = () => {
          // Restore AMD after loading
          if (originalDefine) {
            (window as any).define = originalDefine;
          }
          if (originalRequire) {
            (window as any).require = originalRequire;
          }
          resolve();
        };
        autoRenderScript.onerror = () => {
          // Restore AMD even on error
          if (originalDefine) {
            (window as any).define = originalDefine;
          }
          if (originalRequire) {
            (window as any).require = originalRequire;
          }
          reject(new Error('Failed to load KaTeX auto-render'));
        };
        document.head.appendChild(autoRenderScript);
      };
      script.onerror = () => {
        // Restore AMD even on error
        if (originalDefine) {
          (window as any).define = originalDefine;
        }
        if (originalRequire) {
          (window as any).require = originalRequire;
        }
        reject(new Error('Failed to load KaTeX JS'));
      };
      
      document.head.appendChild(script);
    });
  }

  private async loadKaTeXCSS(): Promise<void> {
    return new Promise((resolve, reject) => {
      // Check if KaTeX CSS is already loaded
      const existingLink = document.querySelector('link[href*="katex"]');
      if (existingLink) {
        resolve();
        return;
      }

      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css';
      link.crossOrigin = 'anonymous';
      
      link.onload = () => resolve();
      link.onerror = () => reject(new Error('Failed to load KaTeX CSS'));
      
      document.head.appendChild(link);
    });
  }

  async renderMath(container: HTMLElement): Promise<void> {
    if (!this.katex) {
      await this.loadKaTeX();
    }

    if (!this.katex || !(window as any).renderMathInElement) {
      console.warn('⚠️ KaTeX or auto-render not available, skipping math rendering');
      return;
    }

    try {
      // Use KaTeX auto-render to find and render all math
      (window as any).renderMathInElement(container, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ],
        throwOnError: false,
        errorColor: '#cc0000',
        macros: {
          '\\RR': '\\mathbb{R}',
          '\\NN': '\\mathbb{N}',
          '\\ZZ': '\\mathbb{Z}',
          '\\QQ': '\\mathbb{Q}',
          '\\CC': '\\mathbb{C}',
          '\\matrix': '\\begin{matrix}#1\\end{matrix}',
          '\\pmatrix': '\\begin{pmatrix}#1\\end{pmatrix}',
          '\\bmatrix': '\\begin{bmatrix}#1\\end{bmatrix}',
          '\\vmatrix': '\\begin{vmatrix}#1\\end{vmatrix}',
          '\\Bmatrix': '\\begin{Bmatrix}#1\\end{Bmatrix}'
        },
        trust: true,
        strict: false
      });

      console.log('✅ KaTeX auto-render completed successfully');
    } catch (error) {
      console.error('❌ Math rendering failed:', error);
    }
  }



  // Render math in a specific string (for export)
  async renderMathInHTML(html: string): Promise<string> {
    if (!this.katex) {
      await this.loadKaTeX();
    }

    if (!this.katex) {
      console.warn('⚠️ KaTeX not available for HTML rendering');
      return html;
    }

    try {
      // Create temporary container
      const container = document.createElement('div');
      container.innerHTML = html;
      
      // Render math in container
      await this.renderMath(container);
      
      return container.innerHTML;
    } catch (error) {
      console.error('❌ Failed to render math in HTML:', error);
      return html;
    }
  }

  isReady(): boolean {
    return !!this.katex;
  }

  isLoadingKaTeX(): boolean {
    return this.isLoading;
  }
}

// Export singleton instance
export const katexRenderer = new KaTeXRenderer();

// Convenience function for rendering math in an element
export async function renderMathInElement(element: HTMLElement): Promise<void> {
  await katexRenderer.renderMath(element);
}

// Convenience function for rendering math in HTML string
export async function renderMathInHTML(html: string): Promise<string> {
  return katexRenderer.renderMathInHTML(html);
}

export default katexRenderer;