// KaTeX Client-side Renderer
// Renders math expressions after HTML is generated by worker

interface KaTeXOptions {
  displayMode?: boolean;
  throwOnError?: boolean;
  errorColor?: string;
  macros?: Record<string, string>;
}

class KaTeXRenderer {
  private katex: any = null;
  private isLoading = false;
  private loadPromise: Promise<void> | null = null;

  async loadKaTeX(): Promise<void> {
    if (this.katex) return;
    if (this.loadPromise) return this.loadPromise;

    this.isLoading = true;
    this.loadPromise = this.doLoadKaTeX();
    
    try {
      await this.loadPromise;
    } finally {
      this.isLoading = false;
    }
  }

  private async doLoadKaTeX(): Promise<void> {
    try {
      // Load KaTeX dynamically
      const [katexModule] = await Promise.all([
        import('katex'),
        this.loadKaTeXCSS()
      ]);
      
      this.katex = katexModule.default;
      console.log('✅ KaTeX loaded successfully');
    } catch (error) {
      console.error('❌ Failed to load KaTeX:', error);
      throw error;
    }
  }

  private async loadKaTeXCSS(): Promise<void> {
    return new Promise((resolve, reject) => {
      // Check if KaTeX CSS is already loaded
      const existingLink = document.querySelector('link[href*="katex"]');
      if (existingLink) {
        resolve();
        return;
      }

      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css';
      link.crossOrigin = 'anonymous';
      
      link.onload = () => resolve();
      link.onerror = () => reject(new Error('Failed to load KaTeX CSS'));
      
      document.head.appendChild(link);
    });
  }

  async renderMath(container: HTMLElement): Promise<void> {
    if (!this.katex) {
      await this.loadKaTeX();
    }

    if (!this.katex) {
      console.warn('⚠️ KaTeX not available, skipping math rendering');
      return;
    }

    try {
      // Render inline math
      const inlineMath = container.querySelectorAll('.katex-inline[data-math]');
      for (const element of inlineMath) {
        await this.renderElement(element as HTMLElement, false);
      }

      // Render block math
      const blockMath = container.querySelectorAll('.katex-block[data-math]');
      for (const element of blockMath) {
        await this.renderElement(element as HTMLElement, true);
      }

      console.log(`✅ Rendered ${inlineMath.length} inline and ${blockMath.length} block math expressions`);
    } catch (error) {
      console.error('❌ Math rendering failed:', error);
    }
  }

  private async renderElement(element: HTMLElement, displayMode: boolean): Promise<void> {
    const mathText = element.getAttribute('data-math');
    if (!mathText) return;

    try {
      const options: KaTeXOptions = {
        displayMode,
        throwOnError: false,
        errorColor: '#cc0000',
        macros: {
          '\\RR': '\\mathbb{R}',
          '\\NN': '\\mathbb{N}',
          '\\ZZ': '\\mathbb{Z}',
          '\\QQ': '\\mathbb{Q}',
          '\\CC': '\\mathbb{C}'
        }
      };

      // Clear existing content
      element.innerHTML = '';
      
      // Render with KaTeX
      this.katex.render(mathText, element, options);
      
      // Mark as rendered
      element.classList.add('katex-rendered');
      
    } catch (error) {
      console.error('❌ Failed to render math expression:', mathText, error);
      
      // Show error in element
      element.innerHTML = `<span class="katex-error">Math Error: ${mathText}</span>`;
      element.classList.add('katex-error');
    }
  }

  // Render math in a specific string (for export)
  async renderMathInHTML(html: string): Promise<string> {
    if (!this.katex) {
      await this.loadKaTeX();
    }

    if (!this.katex) {
      console.warn('⚠️ KaTeX not available for HTML rendering');
      return html;
    }

    try {
      // Create temporary container
      const container = document.createElement('div');
      container.innerHTML = html;
      
      // Render math in container
      await this.renderMath(container);
      
      return container.innerHTML;
    } catch (error) {
      console.error('❌ Failed to render math in HTML:', error);
      return html;
    }
  }

  isReady(): boolean {
    return !!this.katex;
  }

  isLoadingKaTeX(): boolean {
    return this.isLoading;
  }
}

// Export singleton instance
export const katexRenderer = new KaTeXRenderer();

// Convenience function for rendering math in an element
export async function renderMathInElement(element: HTMLElement): Promise<void> {
  await katexRenderer.renderMath(element);
}

// Convenience function for rendering math in HTML string
export async function renderMathInHTML(html: string): Promise<string> {
  return katexRenderer.renderMathInHTML(html);
}

export default katexRenderer;